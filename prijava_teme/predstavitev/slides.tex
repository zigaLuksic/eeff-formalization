% ChkTex-file 46

\documentclass[usenames,dvipsnames]{beamer}
\usetheme{boadilla}
\usecolortheme{spruce}
\setbeamertemplate{navigation symbols}{}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{newtxmath}
\usepackage{ifthen}
\usepackage{xcolor}
\usepackage{epigraph}
\usepackage{tikz-cd}
\usepackage{float}
\usepackage{framed}
\usepackage{caption}
\usepackage{tcolorbox}
\definecolor{shadecolor}{rgb}{0.95,0.95,0.95}
\definecolor{newstuff}{rgb}{0.20,0.50,0.75}
\include{macros}

\title[Applications of algebraic effect theories]{\LARGE Applications of algebraic effect theories}
\author[Žiga Lukšič]{Žiga Lukšič \\ Mentor: doc.\ dr.\ Matija Pretnar}
\date{9.\ 5.\ 2019}
%===============================================================================
\begin{document}
%===============================================================================
\begin{frame}
  \titlepage
\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
	\frametitle{Reasoning about programs}
	
  \begin{align*}
		f_1 =& \;\fun{x}{x + x}\\
		f_2 =& \;\fun{x}{2*x}
	\end{align*}

	We know mathematical properties of operations $+$ and $*$ so we can argue that the functions are equal \textcolor{gray}{(whatever that means)}.
	
	\vspace{5mm}

	Harder with effectful operations, such as $print$.

	\begin{align*}
		print\_twice =& \;\fun{s}{\apply{print}{s};\,\apply{print}{s}}\\
		print\_double =& \;\fun{s}{\apply{print}{s \, \concat s}}
	\end{align*}

	%($c_1;\,c_2$ \textcolor{gray}{is syntactic sugar for} $\dobind{\_}{c_1}{c_2}$)

\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
	\frametitle{``Implementing print''}
	
	We give meaning to operations with handlers. An example:

	\begin{align*}
		&\mathit{collect\_prints} \; = \; \keyhandler \; \{ \\
		&\tab | \; \operation[print]{s}{k} \mapsto \\
		&\tab \tab \tab \betterdobind{(v, s')}{\apply{k}{\unit}}(v, s\,\concat s')\\
		&\tab | \; \return{x} \mapsto (x, "") \\
		&\}
	\end{align*}

\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}

	What happens when we combine them?
	\pause

	\[ \withhandle{\mathit{collect\_prints}}{(\apply{print\_twice}{"test"})} \]
	\pause

	When the first $print$ occurs, our handler `intercepts' the operation call

	\[ \operation[print]{"test"}{\unit.\apply{print}{"test"}} \]
	\pause

	It `activates' the $print$ branch of the handler and it first wraps the continuation

	\[
		k = \fun{\unit}{\withhandle{\mathit{collect\_prints}}{(\apply{print}{"test"})}}
	\]

	\pause

	and proceeds with the evaluation
	\begin{align*}
		&\betterdobind{(v, s')}{\apply{k}{\unit}}\\
		&(v, "test"\concat s')
	\end{align*} 


\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
	When using the handler $\mathit{collect\_prints}$ the functions $print\_twice$ and $print\_double$ are indeed equal.

	\vspace{5mm}

	This does not hold for arbitrary $print$ handlers.

	\pause
	\vspace{5mm}

	\textbf{We want reasoning tools that can separate handlers from the rest of our code!}
\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
	The theory of algebraic effects consists of operations and \textbf{equations} between them.

	\vspace{5mm}

	We can use equations such as

	\[
		\apply{print}{s_1};\, \apply{print}{s_2} \rel \apply{print}{s_1  \concat \, s_2}
	\]

	as reasoning tools.

	\vspace{5mm}

	\pause

	Can we achieve that without restricting ourselves to a global effect theory?

\end{frame}
%-------------------------------------------------------------------------------
%0000000000000000000000000000000000000000000000000000000000000000000000000000000
%-------------------------------------------------------------------------------
\begin{frame}
	\frametitle{Idea}
	Include the desired equations in types.

  \[
    \ctyC = \tyA \bang \sig \new{\witheq \eqE}
  \]

  Operations of type $\ctyC$ either return a value of type $\tyA$ or call an operation from $\sig$ \new{in the effect theory $\eqE$}.
  \vspace{5mm}

  Equations in $\eqE$ tell us what computations we deem equal.
\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Term Syntax}
  
\[
	\begin{array}{rrll}
		\text{values}~v
		 & ::=   & x                                                                              & \text{variable}          \\
		 & \vsep & \unit                                                                          & \text{unit constant}     \\
		 & \vsep & \true \vsep \false                                                             & \text{boolean constants} \\
		 & \vsep & \fun{x}{c}                                                                     & \text{function}          \\
		 & \vsep & \handler{\hcases}                                                              & \text{handler}           \\
		 \\
		 \text{computations}~c
		 & ::=   & \ifclause{v}{c_1}{c_2}                                                         & \text{conditional}       \\
		 & \vsep & \apply{v_1}{v_2}                                                               & \text{application}       \\
		 & \vsep & \return{v}                                                                     & \text{returned value}    \\
		 & \vsep & \operation{v}{y.c}                                                             & \text{operation call}    \\
		 & \vsep & \dobind{x}{c_1}{c_2}                                                           & \text{sequencing}        \\
		 & \vsep & \withhandle{v}{c}                                                              & \text{handling}					\\
		 \\
		 \text{operation clauses}~\hcases
		  & ::=   & \emptyhcases \vsep \hcases \union \set{\operation{x}{\contin} \mapsto c_{\op}}                            \\
		\end{array}
		\]
\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Type Syntax}
  \[
	\begin{array}{rrll}
		\text{(value) type}~\tyA, \tyB
		 & ::=   & \unittype          & \text{unit type}\\
		 & \vsep & \booltype          & \text{boolean type}\\
		 & \vsep & \tyA \to \ctyC     & \text{function type}\\
		 & \vsep & \ctyC \hto \ctyD   & \text{handler type}\\
		\\
		\text{computation type}~\ctyC, \ctyD
		 & ::=   & \ctype{\tyA}{\sig}{\new{\eqE}}\\
		\\
		\text{signature}~\sig
		 & ::=   & \nil \vsep \sig \union \set{{\op \oftype \tyA \to \tyB}}\\
	\end{array}
\]


\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Type Syntax (additions)}
  \[
	\begin{array}{rrll}
		\text{value context}~\ctx
		 & ::=   & \varepsilon \vsep \ctx, x \oftype \tyA \\
		\\
		\new{ \text{template context}}~\tvars
		 & ::=   & \varepsilon \vsep \tvars, z \oftype \tyA \to \anytype \\
    \\
		\new{\text{template}}~\tmplT
		 & ::=   & \apply{z}{v} \\
		 & \vsep & \ifclause{v}{\tmplT_1}{\tmplT_2} \\
		 & \vsep & \operation{v}{y.\tmplT} \\
		\\
		\new{\text{(effect) theory}}~\eqE
		 & ::=   & \nil \vsep \eqE \union
		\set{\teqjudgement{\tenv}{\tmplT_1 \rel \tmplT_2}}\\
	\end{array}
  \]
  
  The \emph{any type} \new{$\anytype$} used in template types can be instantiated to any computation type so that we can reuse templates.
\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Full equation}
	\[\tenv = \tenvlong
			{(x \oftype \texttt{string}, y \oftype \texttt{string})}
    	{(z \oftype \unittype \to \anytype)}
	\]
	
	\[
    \teqjudgement{\tenv}
      {
      \mathit{print}(x; \_.\mathit{print}(y; \_.\apply{z}{\unit}))
      \rel
      \mathit{print}(x \concat y; \_.\apply{z}{\unit})
      }
  \]
\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
	\frametitle{Assigning types}
	
	Assume a slightly richer language (with strings and pairs).

	\vspace{5mm}

	Without equations, $\mathit{collect\_prints}$ would have the type
	\[
		{\tyA}\bang{\set{print}} \hto {(\tyA * string)}\bang{\nil}
	\]

	\pause

	But before we wanted to use the theory
	\begin{equation*}
		E_{no\_sep} = \left( \apply{print}{s_1};\, \apply{print}{s_2} \rel \apply{print}{s_1  \concat \, s_2} \right)
	\end{equation*}

	so we could instead use the type
	\[
		\ctype{\tyA}{\set{print}}{E_{no\_sep}} \hto \ctype{(\tyA * string)}{\nil}{\nil}
	\]

\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
	\frametitle{Another example}
	\begin{align*}
		&\mathit{use\_newline} \; = \; \keyhandler \; \{ \\
		&\tab | \; \operation[print]{s}{k} \mapsto \apply{print}{s};\,\apply{print}{"\backslash n"};\, \apply{k}{\unit}\\
		&\tab | \; \return{x} \mapsto x \\
		&\}
	\end{align*}

	\begin{align*}
		E_{no\_sep} &= \apply{print}{s_1};\,\apply{print}{s_2} \rel \apply{print}{s_1 \concat\, s_2}\\
		E_{sep} &= \apply{print}{s_1};\,\apply{print}{s_2} \rel \apply{print}{s_1 \concat\, "\backslash n" \concat \, s_2}	
	\end{align*}

	\[
		\mathit{use\_newline} \oftype \ctype{\tyA}{\set{print}}{E_{sep}} \hto \ctype{(\tyA)}{\set{print}}{E_{no\_sep}}
	\]

\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
	\frametitle{How to type handlers?}
	All typing rules remain largely the same as when not using equations.

	\vspace{5mm}

	The only important change is
	\[
		\inferrule*[]
		{
			\judgement{\ctx, x \oftype \tyA}{c_r}{\ctyD}
			\\
			\new{\respects{\hcases}{\eqE}{\sig}{\ctyD}}
			\\
		}
		{\judgement{\ctx}
			{\handler{\hcases}}
			{\ctype{\tyA}{\sig}{\eqE} \hto \ctyD}
		}
	\]

\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
	\frametitle{How to type handlers?}
	
	We must check $\new{\respects{\hcases}{\eqE}{\sig}{\ctyD}}$ in a logic, but we have a choice which logic to use.

	\vspace{5mm}

	The general idea is checking that our handler maps equivalent computations to equivalent computations.

	\vspace{5mm}

	The choice of logic also bears impact on the denotational semantics of our language.

\end{frame}
%-------------------------------------------------------------------------------
\begin{frame}
	\frametitle{Future work}
	
	\begin{itemize}
		\item Implement the new type system.
		\item Consider options for easier checks of the \new{respects} relation.
		\item How to define subtyping?
		\item How to use such systems for formalisation (probabilistic programming)?
	\end{itemize}

\end{frame}
%===============================================================================
\end{document}
%===============================================================================