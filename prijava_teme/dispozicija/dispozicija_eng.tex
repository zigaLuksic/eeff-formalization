%chktex-file 46
\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{newtxmath}
\usepackage{ifthen}
\usepackage{xcolor}
\usepackage{epigraph}
\usepackage{tikz-cd}
\usepackage{float}
\usepackage{framed}
\usepackage{caption}
\usepackage{tcolorbox}
\usepackage{enumitem}

\renewcommand{\and}{\\}
\newcommand{\todo}[1]{{\color{red}{#1}}}

\title{Doctoral dissertation proposal}
\author{Žiga Lukšič \and Mentor: doc.\ dr.\ Matija Pretnar}
\date{}

%===============================================================================
\begin{document}

\maketitle

\vspace{-10mm}
\begin{center}
  \Large{\textsc{\textbf{Uporaba teorij algebrajskih učinkov}}}

  \Large{\textsc{\textbf{Applications of algebraic effect theories}}}
\end{center}

\section*{Overview of the field and current research on the topic}

The use of math based concepts benefits programming language design as shown by increasing integration of functional programming ideas in mainstream languages (higher order functions, anonymous functions, patterns). A language with strong mathematical foundations allows us to present programs as mathematical objects, allowing for strong tools and procedures in formal reasoning of program correctness. As many programs accept input and return the computed value it is natural to interpret them as functions. Yet simple functions do not change their environment, so it is difficult to model computational effects such as printing text, reading data from sensors, or communication with a distant server.

Computational effects may be included with special constructs as programming primitives. This requires us to adapt our language and reasoning system for every additional effect, which leads us to include all of the commonly used computational effects. This however bloats and complicates the foundations of the language. We desire a general approach to effects where adding new effects does not require additional changes to the language itself.

One of the current approaches is based on so called \emph{monads}~\cite{DBLP:journals/iandc/Moggi91}. As show in practice (for instance in the language Haskell) this approach is successful, but using many different effects requires chaining monads which reduces clarity of code.

Another rising approach is using algebraic effects~\cite{DBLP:conf/fossacs/PlotkinP01,DBLP:journals/acs/PlotkinP03} and handlers~\cite{DBLP:conf/esop/PlotkinP09} where computational effects are represented by operations. Operations and equations between them form an algebraic theory of effects e.g.\ we consider an operation representing nondeterministic choice, written as $x \oplus y$, where an example equation would be commutativity of choice i.e.\ $x  \oplus y \sim y \oplus x$.

Operation calls are given meaning by the algebraic handlers, which intercept the call and run the instructed computations. Algebraic handlers can be seen as a generalisation of exception handlers with an additional possibility of continuing the evaluation of the program. Returning to the example of nondeterministic choice, when $x \oplus y$ is called, the handling handler has acces to the arguments of the operation $x$ and $y$ and the programs continuation, which awaits a choice of one of the arguments and is stored in the function $k$. When implementing handlers we have a plethora of options, such as a handler that always selects the first option by continuing with $k \; x$ or perhaps we calculate both options, $k \; x$ and $k \; y$ and choose the optimal one (for instance the one that results into a higher value). We implicitly handle the continuation with the same handler. But because our effect theory includes equations, we require that our handlers respect them. In that case, handlers can be seen as homomorphisms between models of theories, motivating that only such handlers are allowed~\cite{DBLP:conf/esop/PlotkinP09}. This requirement was soon dropped as there are many useful handlers which do not respect equations (and are thus homomorphisms only from absolutely free models), allowing for greater expressivity when defining handlers.

Even though equations impose restrictions on handlers they remain a vital part of the effect theory, as we can use equations to describe the interactions between effects. If our program prints \texttt{"algebraic"} and then \texttt{" effects"} it might as well print only \texttt{"algebraic effects"}. We can express this with the equation $print(x); print(y) \sim print(x\;\hat{}\;y)$. This is but one of the many examples of equations on which we rely when programming. Another example is commutativity of inserting elements into mutable sets, as expressed by the equation $add(x);\; add(y) \sim add(y);\; add(x)$. Equations enable us to describe the behaviour of operations and thus allow decoupling of handlers from handled code when reasoning. We reason about code in the desired effect theory with no regards to the handler implementation. We separately prove that the chosen handlers respect the effect theory, enabling us to use them. Due to the separation we can switch between handlers as long as they respect the theory without impacting the correctness of our program. This approach would allow to break up certain proofs (such as in~\cite{DBLP:journals/jlp/BauerP15}) into smaller and more structured pieces, which can then be combined into proofs of correctness of more intricate programs.

When developing the theory of algebraic effects and handlers they have upgraded the type system with additional information about effects~\cite{DBLP:journals/corr/BauerP13, DBLP:conf/icfp/KammarLO13}. The type system keeps track of which operations might be called and also which operation calls are handled away by handlers. There have been attempts at including equations in the type system with the use of dependant types~\cite{DBLP:journals/pacmpl/Ahman18}, but requires a more complex type system. The goal is to reintroduce equations back into languages with algebraic effects in a way that is as simple as possible and also true to the original ideas~\cite{DBLP:phd/ethos/Pretnar10}.

\section*{Design of research}

Despite algebraic effects gaining popularity in mainstream functional programming, the field of explicit equations between effects remains largely unresearched. While there is promising work with dependant types~\cite{DBLP:journals/pacmpl/Ahman18}, using simpler type systems requires less changes to operational and denotational semantics making such approaches more favourable for implementation and general use. While changes to the type system are kept to a minimum, types now include equations, which describe programs, which yet again depend on types. The system must be defined with great care to ensure that we avoid any and all circular definitions. 

In the same way that effect systems progressed to local effect signatures it is possible to also switch to local effect theories. While effect theories used to be global~\cite{DBLP:conf/esop/PlotkinP09}, forcing all handlers to respect the global theory, switching to local theories allows us to rely on effect theories in some parts of the program while we use handlers that do not respect the theory in other parts where equations are not required.

In order for the type system to ensure that handlers respect the desired effect theory we require a logic where such properties can be expressed and proven. If possible, the use of different logics should be used, allowing us to switch to a more expressive logic when needed. This allows multiple implementations of logics.

My research will focus on establishing a more powerful reasoning system, aided by local effect theories in their original form, to allow for proofs that do not require concrete handlers.

\section*{Research questions}

\begin{itemize}
  \item How to extend the type system to include local theories while avoiding cyclic definitions?
  \item How does the choice of logic impact our language and its denotational semantics and how do we implement suitable logics?
  \item How do we construct tools similar to quickcheck~\cite{DBLP:conf/icfp/ClaessenH00} to at aid us with catching errors?
  \item How do we adapt properties such as safety, soundness, adequacy, and contextual equivalence in presence of equations?
  \item How do equations help with reasoning in presence of abstractions, where we can describe properties of black-box programs with equations?
  \item In which applicative cases are we aided by the use of equations?  Do such approaches benefit fields such as statistical programing~\cite{DBLP:journals/pacmpl/VakarKS19}?
\end{itemize}



\section*{Expected results and original contribution to science}

By reintroducing equations we return to the original concept of algebraic effects, improving reasoning and program safety through local theories, and allows for effect-dependant optimisation. We further improve it by introducing local theories, which help alleviate restrictions on handler definitions. Improved reasoning capabilities will allow algebraic effects to anchor in mainstream languages. I suspect that there will be many options in the choice of logic, ranging from logics that express the current system without equations to far more powerful logics that greatly benefit users. 

\bibliographystyle{fmf-en}
\bibliography{bibliography}

\end{document}
