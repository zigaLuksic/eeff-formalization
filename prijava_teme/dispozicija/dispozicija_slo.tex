%chktex-file 46
\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{newtxmath}
\usepackage{ifthen}
\usepackage{xcolor}
\usepackage{epigraph}
\usepackage{tikz-cd}
\usepackage{float}
\usepackage{framed}
\usepackage{caption}
\usepackage{tcolorbox}
\usepackage{enumitem}

\renewcommand{\and}{\\}
\newcommand{\todo}[1]{{\color{red}{#1}}}

\title{Dispozicija doktorske disertacije}
\author{Žiga Lukšič \and Mentor: doc.\ dr.\ Matija Pretnar}
\date{}

%===============================================================================
\begin{document}

\maketitle

\vspace{-10mm}
\begin{center}
  \Large{\textsc{\textbf{\todo{???}}}}

  \Large{\textsc{\textbf{\todo{??? but in english}}}}
\end{center}

\section*{Pregled področja in dosedanjih raziskav}

Uporaba matematično dobro osnovanih konceptov v programskih jezikih se je v praksi izkazala za koristno, na kar kaže vse pogostejša raba idej iz funkcijskih programskih jezikov. Če ima naš jezik močne matematične temelje, lahko programe predstavimo z matematičnimi objekti, kar nam nudi močna orodja za analizo in formalno dokazovanje pravilnosti programov. Mnogo programov potrebuje nekakšen vnos in nam vrne izračun, torej je naravno, da jih predstavljamo s funkcijami. Vendar preproste funkcije ne vplivajo na svoje okolje, zaradi česar so računski učinki, kot na primer izpisovanje besedila na zaslonu, odčitavanje podatkov iz senzorjev ali komunikacija z oddaljenim strežnikom, velik izziv za matematično formulacijo.

Računske učinke lahko v programski jezik dodajamo kot posebne konstrukte, vendar moramo temu primerno za vsak dodani učinek prilagoditi pomen naših programov in pristope k formalnemu dokazovanju. Ker s tem omejimo uporabnike jezika na zgolj že vgrajene učinke, bi želeli dodati vse pogosto rabljene učinke, s čimer pa postajajo temelji našega jezika kompleksnejši. Zato želimo k problemu računskih učinkov pristopiti z rešitvami, ki omogočajo strukturirano dodajanje učinkov brez prilagajanja programskega jezika.

Ena od takšnih rešitev temelji na t.i.\ \emph{monadah}~\cite{DBLP:journals/iandc/Moggi91}. Monadični pristop k učinkom deluje, kot dokazujejo programski jeziki kot je Haskell, vendar uporaba različnih učinkov zahteva veriženje monad kar pri veliki količini učinkov zmanj\-šuje preglednost kode.

Drug pristop k računskim učinkom je uporaba algebrajskih učinkov~\cite{DBLP:conf/fossacs/PlotkinP01, DBLP:journals/acs/PlotkinP03} in prestreznikov~\cite{DBLP:conf/esop/PlotkinP09}, kjer računske učinke predstavimo z pripadajočimi operacijami, te pa so med seboj povezane z algebrajskimi enačbami. Operacije skupaj z enačbami tvorijo algebrajsko teorijo učinkov. Za primer lahko za operacijo vzamemo nedeterministično izbiro med dvema elementoma, kar pišemo kot $x \oplus y$, primer enačbe v teoriji nedeterministične izbire pa je recimo komutativnost, torej $x \oplus y \sim y \oplus x$.

Operacijam pomen dodelimo z algebrajskimi prestreznikov, ki prestrežejo klic operacije in zaženejo izbran izračun. Algebrajske prestreznike si lahko predstavljamo kot posplošitev prestreznikov izjem, le da ima uporabnik možnost nadaljevanja programa. Na primer, če v kodi uporabimo nedeterministično izbiro $x \oplus y$, operacijo prestreže dodeljeni prestreznik, kateri ima dostop do argumentov operacije ($x$ in $y$) in pa možnost nadaljevanja programa (funkcija $k$), ki pričakuje izbiro enega od elementov. Na nadaljevanju programa vedno implicitno uporabimo prestreznik, ki je prestregel operacijo. Pri implementaciji prestreznikov imamo proste roke, torej lahko napišemo prestreznik, ki vedno izbere levi element, torej zažene nadaljevanje $k\; x$, lahko pa izračunamo obe možnosti, $k\; x$ in $k\; y$ in se odločimo za boljšo izbiro (npr. tisto, ki vrne večjo vrednost). Ker pa med operacijami veljajo enačbe teorije učinkov, jih morajo prestrezniki temu primerno spoštovati. Takšni prestrezniki delujejo kot homomorfizmi med modeli teorij, zaradi česar so v izvorni obliki bili dovoljeni zgolj prestrezniki, ki zadoščajo enačbam~\cite{DBLP:conf/esop/PlotkinP09}. Ker veliko zanimivih in uporabnih prestreznikov ne zadošča enačbam teorij (in so zato homorfizmi zgolj med absolutno prostimi modeli), so enačbe pogosto izpuščene zavoljo večje ekspresivnosti prestreznikov.

Kljub omejevanju možnih prestreznikov, so enačbe pomemben del teorije računskih učinkov. Če naš program izpiše niz \texttt{"algebrajski"} in nato še \texttt{" učinki"}, bi lahko enako dosegli z zgolj enim izpisom \texttt{"algebrajski učinki"}. To lahko izrazimo z enačbo $print(x); print(y) \sim print(x\;\hat{}\;y)$. To je zgolj eden od primerov enačb, na katere se zanašamo med programiranjem. Podoben primer je komutativnost dodajanja elementov v spremenljivo množico, torej $add(x);\; add(y) \sim add(y);\; add(x)$. Vendar če ne preverimo, da prestrezniki spoštujejo teorijo, moramo pravilnost kode pokazati pri uporabi vsakega posameznega prestreznika. Zagotavljanje modularnosti prestreznikov motivira uporabo teorij učinkov, saj želimo kodo programa ločiti od kode uporabljenih prestreznikov. Lastnosti kode dokazujemo v želeni teoriji učinkov in se pri tem ne oziramo na implementacijo prestreznikov, temveč zgolj upoštevamo enačbe teorije. Nato pokažemo, da izbrani prestrezniki spoštujejo izbrano teorijo in s tem zagotovimo, da jih lahko uporabimo na programu. Ker v dokazu kode ne uporabimo definicije prestreznikov lahko prestreznike zamenjamo z drugimi, ki spoštujejo teorijo učinkov, in s tem ne vplivamo na pravilnost skupnega dokaza. S tem pristopom nekatere dokaze (kot npr.\ v~\cite{DBLP:journals/jlp/BauerP15}) razbijemo na manjše in strukturirane kose, ki jih nato komponiramo v dokaze kompleksnejših programov.

Pri uvedi algebrajskih prestreznikov so sistem tipov nadgradili z informacijami o učinkih~\cite{DBLP:conf/esop/PlotkinP09}. To je obsegalo tako informacije o tem, kateri učinki se lahko sprožijo v programu, kot tudi katere učinke prestreznik prestreže. Razvoj sistema tipov in učinkov se je nadaljeval v dveh smereh: t.i.\ `row-types'~\cite{DBLP:conf/icfp/HillerstromL16} in `subtyping'~\cite{DBLP:conf/esop/SalehKPS18}. Prav tako se je pričelo tudi dodajanja enačb v sisteme tipov~\cite{DBLP:journals/pacmpl/Ahman18} vendar zahteva uporabo zahtevnejših odvisnih tipov. Zato želimo enačbe dodati v tipe na preprostejši način, ki zahteva manjšo prilagoditev jezika in je bolj v skladu z izvornim pristopom~\cite{DBLP:phd/ethos/Pretnar10}. Tako kot se uveljavlja uporaba učinkov z lokalno signaturo, lahko tudi enačbe dodajamo lokalno, s čimer pridobimo lokalne teorije učinkov. V izvornemu pristopu je teorija učinkov globalna~\cite{DBLP:conf/esop/PlotkinP09}, torej morajo teoriji zadoščati vsi prestrezniki. Ker pa mnogi uporabni prestrezniki ne spoštujejo teorij, jih lahko pri uporabi lokalnih teorij kljub temu uporabljamo v delih programov, kjer ne zahtevamo enačb.

\section*{Opis raziskovalne vsebine}

Kljub temu, da se je teorija algebrajskih učinkov uveljavila v sferi funkcijskega programiranja, ostaja področje eksplicitnih enačb med učinki še precej neraziskano področje. Kljub začetkom dela z odvisnimi tipi~\cite{DBLP:journals/pacmpl/Ahman18} ostaja še mnogo neraziskanih pristopov, ki nam nudijo preprostejši sistem tipov. S tem pridobimo preglednejšo operacijsko in denotacijsko semantiko, zaradi česar so takšni sistemi primernejši za implementacijo in splošnejšo uporabo. Kljub manj obsežnim spremembam tipi vsebujejo enačbe, ki govorijo o programih, ti pa se spet zanašajo na tipe, torej je pomembno, da poskrbimo za neciklične definicije. Poudarek mojega pristopa bo predvsem na preprostem sistemu formalnega dokazovanja pri uporabi algebrajskih učinkov, kjer bo ključnega pomena dokazovanje pravilnosti brez prisotnosti konkretnih prestreznikov, saj lahko zgolj v tem primeru zagotovimo modularnost. S tem se odprejo aplikativna področja kot je na primer statistično programiranje, kjer je uporaba učinkov naravna, hkrati pa je nujno zagotoviti določene lastnosti kode. Prav tako olajšamo dokazovanje v prisotnosti abstrakcije, saj lahko lastnosti programov, katerih koda je nedostopna, izrazimo z enačbami.

\section*{Raziskovalna vprašanja}

\begin{itemize}
  \item Kako prilagodimo tipe, da vključujejo lokalne teorije, brez cikličnih definicij?
  \item Koliko različnih logik imamo na izbiro in kako izbrati primerno?
  \item Kako izbira logike vpliva na jezik in denotacijsko semantiko jezika?
  \item Je problem, ali prestreznik spoštuje teorijo, odločljiv? Ali lahko v primeru neodločljivosti problem delno rešimo z orodji kot je quickcheck~\cite{DBLP:conf/icfp/ClaessenH00}?
  \item Kako prilagoditi lastnosti kot so varnost, zdravost, zadostnost in kontekstno ekvivalenco v prisotnosti enačb?
  \item V katerih aplikativnih primerih nam uporaba enačb pomaga? Ali lahko s pomočjo modularnih dokazov izboljšamo pristope na področjih kot je statistično programiranje?
\end{itemize}


\section*{Pričakovani rezultati in prispevek k znanosti}

Z vrnitvijo enačb  bo teorija algebrajskih učinkov ponovno takšna, kot je bila izvorno zamišljena. Hkrati bo teorija nadgrajena z uporabo lokalnih teorij, s čimer odstranimo omejitve pri pisanju prestreznikov. Izboljšanje možnosti dokazovanja bodo tako omogočile prodor algebrajskih učinkov v širše sfere uporabe in odstranile mističnost algebrajskih prestreznikov. Domnevam, da bo na voljo mnogo različnih logik, s katerimi bo možno izraziti tako trenutni sistem prestreznikov, kjer enačbe ne igrajo vloge, kot tudi sisteme kjer enačbe uporabnikom pomagajo. Ker se je pri uvedbi prestreznikov~\cite{DBLP:conf/esop/PlotkinP09} izkazalo, da je problem ali prestreznik spoštuje teorijo neodločljiv, pričakujem za ekspresivne logike podoben rezultat.


\renewcommand\refname{Literatura}
\bibliographystyle{abbrv}
\bibliography{bibliography}

\end{document}
