%chktex-file 46
\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{newtxmath}
\usepackage{ifthen}
\usepackage{xcolor}
\usepackage{epigraph}
\usepackage{tikz-cd}
\usepackage{float}
\usepackage{framed}
\usepackage{caption}
\usepackage{tcolorbox}
\usepackage{enumitem}

\renewcommand{\and}{\\}
\newcommand{\todo}[1]{{\color{red}{#1}}}

\title{Dispozicija doktorske disertacije}
\author{Žiga Lukšič \and Mentor: doc.\ dr.\ Matija Pretnar}
\date{}

%===============================================================================
\begin{document}

\maketitle

\vspace{-10mm}
\begin{center}
  \Large{\textsc{\textbf{Uporaba teorij algebrajskih učinkov}}}

  \Large{\textsc{\textbf{Applications of algebraic effect theories}}}
\end{center}

\section*{Pregled področja in dosedanjih raziskav}

Uporaba matematično dobro osnovanih konceptov v programskih jezikih se je v praksi izkazala za koristno, na kar kaže vse pogostejša raba idej iz funkcijskih programskih jezikov (funkcije višjega reda, anonimne funkcije, vzorci). Če ima jezik močne matematične temelje, lahko programe predstavimo z matematičnimi objekti, kar nam nudi močna orodja za analizo in formalno dokazovanje pravilnosti programov. Mnogo programov potrebuje nekakšen vnos in nam vrne izračun, torej je naravno, da jih predstavljamo s funkcijami. Vendar preproste funkcije ne vplivajo na svoje okolje, zaradi česar so računski učinki, kot na primer izpisovanje besedila na zaslonu, odčitavanje podatkov iz senzorjev ali komunikacija z oddaljenim strežnikom, velik izziv za matematično formulacijo.

Računske učinke lahko v programski jezik dodajamo kot posebne konstrukte, vendar moramo temu primerno za vsak dodani učinek prilagoditi pomen naših programov in pristope k formalnemu dokazovanju. S tem uporabnike jezika omejimo na zgolj že vgrajene učinke, zato želimo v jezik dodati vse pogosto rabljene učinke. Vendar s tem postajajo temelji našega jezika kompleksnejši. Zato želimo k problemu računskih učinkov pristopiti z rešitvami, ki omogočajo strukturirano dodajanje učinkov brez prilagajanja programskega jezika.

Ena od takšnih rešitev temelji na t.i.\ \emph{monadah}~\cite{DBLP:journals/iandc/Moggi91}. Monadični pristop k učinkom deluje, kot dokazujejo programski jeziki kot je Haskell, vendar uporaba različnih učinkov zahteva veriženje monad, kar pri veliki količini učinkov zmanj\-šuje preglednost kode.

Drug pristop k računskim učinkom je uporaba algebrajskih učinkov~\cite{DBLP:conf/fossacs/PlotkinP01, DBLP:journals/acs/PlotkinP03} in prestreznikov~\cite{DBLP:conf/esop/PlotkinP09}, kjer računske učinke predstavimo z pripadajočimi operacijami, te pa so med seboj povezane z algebrajskimi enačbami. Operacije skupaj z enačbami tvorijo algebrajsko teorijo učinkov. Za primer lahko za operacijo vzamemo nedeterministično izbiro med dvema elementoma, kar pišemo kot $x \oplus y$, primer enačbe v teoriji nedeterministične izbire pa je recimo komutativnost, torej $x \oplus y \sim y \oplus x$.

Operacijam pomen dodelimo z algebrajskimi prestreznikov, ki prestrežejo klic operacije in zaženejo izbran izračun. Algebrajske prestreznike si lahko predstavljamo kot posplošitev prestreznikov izjem, le da ima uporabnik možnost nadaljevanja programa. Na primer, če v kodi uporabimo nedeterministično izbiro $x \oplus y$, operacijo prestreže dodeljeni prestreznik, ki ima dostop do argumentov operacije $x$ in $y$ ter preostanka programa, ki pričakuje izbiro enega od elementov in je shranjen v funkciji $k$. Pri implementaciji prestreznikov imamo proste roke, torej lahko napišemo prestreznik, ki vedno izbere levi element, torej zažene nadaljevanje $k\; x$, lahko pa izračunamo obe možnosti, $k\; x$ in $k\; y$ in se odločimo za boljšo izbiro (npr. tisto, ki vrne večjo vrednost). Na nadaljevanju programa vedno implicitno uporabimo prestreznik, ki je prestregel operacijo. Ker med operacijami veljajo enačbe teorije učinkov, jih morajo prestrezniki temu primerno spoštovati. Takšni prestrezniki delujejo kot homomorfizmi med modeli teorij, zaradi česar so v izvorni obliki bili dovoljeni zgolj prestrezniki, ki zadoščajo enačbam~\cite{DBLP:conf/esop/PlotkinP09}. Ker veliko zanimivih in uporabnih prestreznikov ne zadošča enačbam teorij (in so zato homomorfizmi zgolj iz absolutno prostih modelov), so enačbe pogosto izpuščene zavoljo večje ekspresivnosti prestreznikov.

Enačbe morda omejujejo nabor možnih prestreznikov, vendar so pomemben del teorije računskih učinkov, saj opišejo interakcijo učinkov. Na primer, če program izpiše niz \texttt{"algebrajski"} in nato še \texttt{" učinki"}, bi lahko enako dosegli z zgolj enim izpisom \texttt{"algebrajski učinki"}. To lahko izrazimo z enačbo $print(x); print(y) \sim print(x\;\hat{}\;y)$. To je zgolj eden od primerov enačb, na katere se zanašamo med programiranjem. Podoben primer je komutativnost dodajanja elementov v spremenljivo množico, torej $add(x);\; add(y) \sim add(y);\; add(x)$. Ker lahko z enačbami opišemo lastnosti operacij, ki jih želimo, lahko pri dokazovanju pravilnosti ločimo kodo programa od kode prestreznikov. Lastnosti programa dokazujemo v želeni teoriji učinkov in se pri tem ne oziramo na implementacijo prestreznikov, temveč zgolj upoštevamo enačbe teorije. Nato pokažemo, da izbrani prestrezniki spoštujejo izbrano teorijo in s tem zagotovimo, da jih lahko uporabimo na programu. Ker v dokazu kode ne uporabimo definicije prestreznikov, lahko prestreznike zamenjamo z drugimi, ki spoštujejo teorijo učinkov, in s tem ne vplivamo na pravilnost skupnega programa. S tem pristopom nekatere dokaze (kot npr.\ v~\cite{DBLP:journals/jlp/BauerP15}) razbijemo na manjše in strukturirane kose, ki jih nato komponiramo v dokaze pravilnosti kompleksnejših programov.

Pri uvedbi algebrajskih prestreznikov so sistem tipov nadgradili z informacijami o učinkih~\cite{DBLP:journals/corr/BauerP13,DBLP:conf/icfp/KammarLO13}. To je obsegalo tako informacije o tem, kateri učinki se lahko sprožijo v programu, kot tudi katere učinke prestreznik prestreže. Prav tako se je pričelo tudi dodajanja enačb v sisteme tipov~\cite{DBLP:journals/pacmpl/Ahman18}, vendar zahteva uporabo kompleksnejših odvisnih tipov. Zato želimo enačbe dodati v tipe na preprostejši način, ki zahteva manjšo prilagoditev jezika in je bolj v skladu z izvornim pristopom~\cite{DBLP:phd/ethos/Pretnar10}.

\section*{Opis raziskovalne vsebine}

Kljub temu, da se je teorija algebrajskih učinkov uveljavila v sferi funkcijskega programiranja, ostaja področje eksplicitnih enačb med učinki še precej neraziskano. Za razliko od uporabe odvisnih tipov~\cite{DBLP:journals/pacmpl/Ahman18}, s preprostejšim sistemom tipov pridobimo preglednejšo operacijsko in denotacijsko semantiko, zaradi česar so takšni sistemi primernejši za implementacijo in splošnejšo uporabo. Kljub manj obsežnim spremembam tipi vsebujejo enačbe, ki govorijo o programih, ti pa se spet zanašajo na tipe, torej je pomembno, da poskrbimo za neciklične definicije. 

Tako kot se uveljavlja uporaba učinkov z lokalno signaturo, lahko tudi enačbe dodajamo lokalno, s čimer pridobimo lokalne teorije učinkov. V izvornemu pristopu je teorija učinkov globalna~\cite{DBLP:conf/esop/PlotkinP09}, torej morajo teoriji zadoščati vsi prestrezniki. Ker pa mnogi uporabni prestrezniki ne spoštujejo teorij, jih lahko pri uporabi lokalnih teorij kljub temu uporabljamo v delih programov, kjer ne zahtevamo enačb.

Da sistem tipov zagotovi, da prestrezniki spoštujejo teorijo učinkov, ga opremimo z logiko, v kateri lahko takšne lastnosti izrazimo in dokažemo. Želimo izbiro med uporabo različnih logik, s čimer omogočimo zamenjavo na močnejšo logiko, ko to potrebujemo. V primeru implementacije različnih logik lahko izberemo najprimernejšo logiko za dokazovanje pravilnosti programa.

Poudarek pristopa bo na vzpostavitvi sistema formalnega dokazovanja pri uporabi teorij učinkov, kjer bo ključnega pomena dokazovanje pravilnosti brez prisotnosti konkretnih prestreznikov, saj lahko zgolj v tem primeru zagotovimo modularnost. 

\section*{Raziskovalna vprašanja}

\begin{itemize}
  \item Kako prilagodimo tipe, da vključujejo lokalne teorije, in se izognemo cikličnim definicijam?
  \item Kako izbira logike vpliva na jezik in denotacijsko semantiko jezika in kako primerne logike implementiramo?
  \item Ali lahko razvijemo orodje kot npr.\ quickcheck~\cite{DBLP:conf/icfp/ClaessenH00}, ki omogoča delno zaznavanje napak?
  \item Kako prilagoditi lastnosti kot so varnost, zdravost, zadostnost in kontekstno ekvivalenco v prisotnosti enačb?
  \item Kako nam uporaba enačb olajša dokazovanje v prisotnosti abstrakcije, kjer lahko lastnosti programov, katerih koda je skrita, izrazimo z enačbami?
  \item V katerih aplikativnih primerih nam uporaba enačb pomaga? Ali lahko s pomočjo naprednejšega sistema dokazovanja pravilnosti izboljšamo pristope na področjih kot je statistično programiranje~\cite{DBLP:journals/pacmpl/VakarKS19}?
\end{itemize}


\section*{Pričakovani rezultati in prispevek k znanosti}

Z vrnitvijo enačb ponovno vzpostavimo teorijo algebrajskih učinkov, s čimer pridobimo nove pristope za dokazovanja pravilnosti programov, izboljšamo varnost programov z uporabo lokalnih teorij ter omogočimo razvoj optimizacij, ki temeljijo na učinkih. Izboljšanje možnosti dokazovanja pravilnosti omogočijo prodor algebrajskih učinkov v širše sfere uporabe. Domnevam, da bo na voljo mnogo različnih logik, s katerimi bo možno izraziti tako trenutni sistem prestreznikov, kjer enačbe ne igrajo vloge, kot tudi sisteme, kjer enačbe uporabnikom pomagajo.


\renewcommand\refname{Literatura}
\bibliographystyle{fmf-sl}
\bibliography{bibliography}

\end{document}
