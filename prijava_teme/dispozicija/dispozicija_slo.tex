%chktex-file 46
\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{newtxmath}
\usepackage{ifthen}
\usepackage{xcolor}
\usepackage{epigraph}
\usepackage{tikz-cd}
\usepackage{float}
\usepackage{framed}
\usepackage{caption}
\usepackage{tcolorbox}
\usepackage{enumitem}

\renewcommand{\and}{\\}
\newcommand{\todo}[1]{{\color{red}{#1}}}

\title{Dispozicija doktorske disertacije}
\author{Žiga Lukšič \and Mentor: dr. Matija Pretnar}
\date{}

%===============================================================================
\begin{document}

\maketitle

\vspace{-10mm}
\begin{center}
  \Large{\textsc{\textbf{Učinki in Enačbe}}}

  \Large{\textsc{\textbf{(Effects and Equations)}}}
\end{center}

\section*{Pregled področja in dosedanjih raziskav}

Pri zasnovi programskih jezikov je ključnega pomena močno matematično ogro\-dje jezika, ki zagotavlja smiselnost in pravilnost napisane kode. Programe lahko predstavimo kot matematične objekte, kar nam omogoča boljši vpogled v delovanje, hkrati pa pridobimo močna orodja za analizo in formalno dokazovanje programov.
Vendar matematični objekti, kot na primer funkcije, ne vplivajo na svoje okolje. Tako so računski učinki, kot na primer izpisovanje besedila na zaslonu, odčitavanje podatkov iz senzorjev ali komunikacija z oddaljenim strežnikom, velik izziv za matematično formulacijo.

Računske učinke lahko dodajamo kot primitivne mehanizme v programski jezik, vendar moramo temu primerno za vsak učinek prilagoditi tudi pomen naših programov in pristope k formalnemu dokazovanju. Ker smo s tem omejeni na zgolj že vgrajene učinke, bi zato želeli dodati vse učinke, ki jih pogosto potrebujemo, s čimer pa postajajo temelji našega jezika kompleksnejši. Zato želimo k problemu računskih učinkov pristopiti z rešitvami, ki omogočajo strukturirano dodajanje učinkov brez prilagajanja programskega jezika.

Ena od takšnih rešitev temelji na t.i.\ \emph{monadah}~\cite{DBLP:journals/iandc/Moggi91}, kjer vrednosti ovijamo v posebne konstruktorje, funkcije pa dvignemo tako, da lahko sprejemajo tako prilagojene vrednosti, vse pa je med seboj povezano s posebnimi zakoni monad. Takšen pristop k učinkom deluje, kot dokazujejo programski jeziki kot recimo Haskell, vendar ima svoje pomanjkljivosti. Uporaba monad spremeni način pisanja kode, uporaba različnih učinkov zahteva veriženje monad s posebnimi pretvorniki in pri veliki količini učinkov zmanjšuje preglednost kode.

Področje se je pričelo z uvedbo zgolj algebrajskih učinkov~\cite{DBLP:conf/fossacs/PlotkinP01, DBLP:journals/acs/PlotkinP03}, kjer vsak računski učinek predstavimo z pripadajočo operacijo. Za primer lahko vzamemo nedeterministično izbiro med dvema elementoma, kar pišemo kot $x \oplus y$. Seveda ne želimo spreminjati semantike programskega jezika za vsak dodani učinek, kar je sprožilo razvoj algebrajskih prestreznikov~\cite{DBLP:phd/ethos/Pretnar10}. Algebrajske prestreznike si lahko predstavljamo kot posplošitev prestreznikov napak, le da imamo v tem primeru možnost nadaljevanja programa. Na primer, če v kodi uporabimo nedeterministično izbiro $x \oplus y$, operacijo prestreže najbližji prestreznik, ki ima dostop do argumentov ($x$ in $y$) in pa nadaljevanja programa ($k$), ki pričakuje izbiro enega od elementov. Pri implementaciji prestreznikov imamo proste roke, torej lahko napišemo prestreznik, ki vedno izbere levi element, torej požene $k\; x$, lahko pa izračunamo obe možnosti, $k\; x$ in $k\; y$ in se odločimo za boljšo izbiro (npr. tisto, ki vrne večjo vrednost). 

Prestreznike ločimo na plitke, ki prestrežejo zgolj prvo pojavitev operacije, in globoke, ki prestrežejo vse pojavitve operacij. Pri globokih prestreznikih implicitno uporabimo prestreznik na nadaljevanju programa $k$ s čimer prestrezniki delujejo kot homomorfizmi med modeli teorij, zaradi česar v nadaljevanju privzemamo globoke prestreznike.

Prestreznik lahko tudi preslika končno vrednost programa, kar omogoča, da prestreznik spremeni tip programa na katerem je uporabljen. Na primer, na programu, ki uporablja nedeterministično izbiro, lahko uporabimo prestreznik, ki zbere vse možne rezultate programa. Če program vrne vrednost $x$ jo pretvori v seznam z enim elementom $[x]$. Če pa program sproži operacijo $x \oplus y$ z kontinuacijo $k$ (na kateri že implicitno uporabimo prestreznik), najprej pridobimo vse rezultate pri prvi izbiri, $l_1 = k x$, nato pa še vse rezultate pri drugi izbiri, $l_2 = k y$ in nato vrnemo sestavljen seznam $l_1 @ l_2$. 

Teorija algebrajskih učinkov seveda ni sestavljena zgolj iz operacij, temveč vsebuje tudi enačbe, ki veljajo med operacijami. Če naš program izpiše niz \texttt{``algebrajski''} in nato \texttt{" učinki"}, bi lahko enako dosegli če bi zgolj enkrat izpisali \texttt{"algebrajski učinki"}. To lahko izrazimo z enačbo $print(x); print(y) \sim print(x\;\hat{}\;y)$. Ko pišemo programe, se pogosto zanašamo na enačbe, na primer da vrstni red pri dodajanju elementov v množice ni pomemben. Vendar če želimo, da je naš program modularen glede izbire prestreznika, takšna predpostavka ni samoumevna. Z enačbami pa lahko to zahtevamo, na primer $add(x); add(y) \sim add(y); add(x)$, in s tem zagotovimo, da bo enačba spoštovana s strani prestreznikov. Enačbe med učinki so ključnega pomena za sklepanje in v izvorni obliki so vsi prestrezniki morali zadoščati določenim enačbam~\cite{DBLP:conf/esop/PlotkinP09}. Ker pa precej uporabnih prestreznikov ne zadošča tem enačbam, je bila zahteva izpuščena zavoljo ekspresivnosti. Tema mojih raziskovanj pa je, kako povrniti enačbe v algebrajske učinke, ter s tem pridobiti vse prednosti teorij algebrajskih učinkov.

V programiranju nam tipi pomagajo pri razumevanju in izboljšajo varnost kode, zato je smiselno, da sistem tipov nadgradimo z informacijami o učinkih~\cite{DBLP:conf/esop/PlotkinP09}. Razvoj sistema tipov z učinki je šel v smeri t.i.\ `row-types'~\cite{DBLP:conf/icfp/HillerstromL16} in pa `subtyping'~\cite{DBLP:conf/esop/SalehKPS18}, začel pa se je tudi razvoj dodajanja enačb v tipe~\cite{DBLP:journals/pacmpl/Ahman18}. Enačbe bi v tipih omogočale sledenje teorijam učinkov. Da prestrezniku dodelimo želen tip, bi morali najprej pokazati, da spoštuje teorijo učinkov, s čimer poskrbimo za ohranjanje varnosti kode. V zadnjem času se uveljavlja uporaba učinkov z lokalno signaturo in podobno lahko enačbe dodajamo lokalno, s čimer pridobimo lokalne teorije učinkov, kar je velika izboljšava napram izvornemu pristopu, kjer je teorija učinkov globalna~\cite{DBLP:conf/esop/PlotkinP09}. Ker pomen učinkov določajo prestrezniki, lahko s tem pristopom prehajamo med lokalnimi teorijami.

Z uporabo enačb pri sklepanju ločimo kodo programa od kode prestreznikov, ki jih uporabljamo. To nam omogoča sklepanje o lastnostih kode v želeni teoriji učinkov, kjer nato ločeno pokažemo, da naši prestrezniki to teorijo spoštujejo. S tem pristopom nekatere dokaze (kot npr.\ v~\cite{DBLP:journals/jlp/BauerP15}) razbijemo na manjše kose. Prav tako lahko uporabimo poljuben prestreznik, ki zadostuje teoriji, in pri tem ne rabimo spremeniti dokaza za program.

\section*{Opis raziskovalne vsebine}

Razvoj zanesljivih in ekspresivnih sistemov tipov skrbi tako za varnost programov kot tudi za sklepanje o lastnostih programa in dokazovanje pravilnosti programske kode. Podobno kot pri pristopu z odvisnimi tipi~\cite{DBLP:journals/pacmpl/Ahman18} želim razširiti sistem tipov tako, da poleg informacije o učinkih hrani tudi informacije o enačbah. S tem lahko opisujemo kakšni teoriji program zadošča kar olajša sklepanje in omogoča razvoj metod optimizacije, ki temeljijo na teoriji učinkov. Da je razširitev primerna želim definirati preko denotacijske semantike, kjer programe prestavimo z matematičnimi objekti. Ker nam enačbe enačijo programe, jih modeliramo z relacijami na matematičnih objektih, poskrbeti pa je potrebno, da programe, ki so enaki na podlagi enačb, slikamo v matematične objekte, ki so v pripadajoči relaciji. 

\section*{Raziskovalna vprašanja}

Želim pokazati, da implementacija enačb v programski jezik z algebrajskimi učinki vzpostavi strukturo teorije učinkov. Nadalje želim raziskati lastnosti, katerim mora zadoščati programski jezik, da v pripadajoči denotacijski semantiki ohranimo želene lastnosti teorije učinkov. Za dokazovanje, da prestreznik zadošča enačbam, moramo v programski jezik vključiti tudi logiko, s katero lahko to izrazimo. Pri izbiri logike imamo mnogo možnosti, zato želim raziskati vpliv izbire logike na jezik ter določiti vpliv izbire logike na denotacijsko semantiko jezika. Poleg razvoja matematičnega ogrodja za teorijo učinkov in konstrukcije primernih logik za dokazovanje, nameravam sistem tudi uporabiti na relevantnih problemih, kot recimo statistično programiranje ali optimizacija kode. Vse konstrukcije nameravam formalizirati z dokazovalniki in izpeljati dokaze za pomembne lastnosti kot so varnost, zdravost in adekvatnost. Želeli bi, da so programi, ki jih teorija učinkov enači, kontekstno ekvivalentni. Domnevam, da ponovno pomembno vlogo igra primerna izbira logike, ki jo uporabljamo v sistemu tipov. 

\section*{Pričakovani rezultati in prispevek k znanosti}

Kljub temu, da se je teorija algebrajskih učinkov uveljavila v sferi funkcijskega programiranja, ostaja področje eksplicitnih enačb med učinki še precej neraziskano področje. Smer moje raziskave napram sorodnim~\cite{DBLP:journals/pacmpl/Ahman18} zahteva manj specializiran sistem tipov in je bolj v skladu z izvornimi idejami~\cite{DBLP:conf/esop/PlotkinP09}. Dopolnitev tipov z enačbami med učinki olajša dokazovanje lastnosti programov, kar je ključnega pomena v mnogih uporabnih aspektih, kot npr.\ statistično programiranje, kjer je varnost naše kode ključnega pomena za kredibilnost rezultatov. Podobno velja za dokazovanje programov, ki uporabljajo knjižnice, kjer lahko sedaj lastnosti tuje kode izrazimo z enačbami brez da odstranimo abstrakcijo in razkrijemo kodo. V primeru dovolj močne denotacijske semantike in kontekstne ekvivalence enačbe prav tako odprejo vrata v optimizacijo na podlagi učinkov, kjer za varnost optimizacij jamčimo preko enačb.

\renewcommand\refname{Literatura}
\bibliographystyle{abbrv}
\bibliography{bibliography}

\end{document}
